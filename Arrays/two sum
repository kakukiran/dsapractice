// brute force method
Time: O(n²) → nested loops
Space: O(1)

int[] twoSumBruteForce(int[] nums, int target) {
  for (int i = 0; i < nums.length; i++) {
    for (int j = 0; j < nums.length; j++) {
      if (nums[i] + nums[j] == target)
        return new int[]{i, j};
    }
  }
  throw new IllegalArgumentException("No two sum solution");
}


// method 1
Time: O(n log n) → for sorting + O(n) → for scanning = O(n log n)
Space: O(n) → due to copied array

int[] twoSumSorting(int[] nums, int target) {
    // Step 1: Copy the array to avoid changing the original
    int[] copyArray = Arrays.copyOf(nums, nums.length);
    
    // Step 2: Sort the copy
    Arrays.sort(copyArray);

    int start = 0;
    int end = copyArray.length - 1;
    int num1 = 0, num2 = 0;

    // Step 3: Use two pointers to find the pair
    while (start < end) {
        int sum = copyArray[start] + copyArray[end];
        if (sum < target) {
            start++; // move start right to increase sum
        } else if (sum > target) {
            end--;   // move end left to decrease sum
        } else {
            num1 = copyArray[start];
            num2 = copyArray[end];
            break;
        }
    }
    // Step 4: Find the indices of num1 and num2 in the original array
    int[] result = new int[2];
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] == num1) result[0] = i;
        else if (nums[i] == num2) result[1] = i;
    }
    return result;
}


//method 2
int[] twoSumHashing(int[] nums, int target) {
  Map<Integer, Integer> map = new HashMap<>();

  for (int i = 0; i < nums.length; i++) {
    int complement = target - nums[i];

    if (map.containsKey(complement)) {
      return new int[]{map.get(complement), i};
    }

    map.put(nums[i], i);
  }

  throw new IllegalArgumentException("No two sum solution");
}

